#pragma kernel HorizontalBlur
#pragma kernel VerticalBlur

Texture2D<float4> InputTex;
RWTexture2D<float4> OutputTex;

float TexelSkip;

[numthreads(8, 8, 1)]
void HorizontalBlur(uint3 id : SV_DispatchThreadID)
{
    const float4 weights[5] = {
        float4(0.227027, 0.227027, 0.227027, 0.227027),
        float4(0.1945946, 0.1945946, 0.1945946, 0.1945946),
        float4(0.1216216, 0.1216216, 0.1216216, 0.1216216),
        float4(0.054054, 0.054054, 0.054054, 0.054054),
        float4(0.016216, 0.016216, 0.016216, 0.016216)
    };

    // static const float4 weights[5] = {
    //     float4(0.104, 0.104, 0.104, 0.104),      // 中心权重 (x=0)
    //     float4(0.104, 0.104, 0.104, 0.104),      // ±1 偏移权重
    //     float4(0.104, 0.104, 0.104, 0.104),      // ±2 偏移权重
    //     float4(0.104, 0.104, 0.104, 0.104),      // ±3 偏移权重
    //     float4(0.104, 0.104, 0.104, 0.104)       // ±4 偏移权重
    // };

    // static const float4 weights[5] = {
    //     float4(0.179, 0.179, 0.179, 0.179),  // 中心
    //     float4(0.168, 0.168, 0.168, 0.168),  // ±1
    //     float4(0.148, 0.148, 0.148, 0.148),  // ±2
    //     float4(0.121, 0.121, 0.121, 0.121),  // ±3
    //     float4(0.092, 0.092, 0.092, 0.092)   // ±4
    // };
    
    // 预计算的扩大过渡区域高斯权重
    // static const float4 weights[5] = {
    //     float4(0.104, 0.104, 0.104, 0.104),
    //     float4(0.169, 0.169, 0.169, 0.169),
    //     float4(0.192, 0.192, 0.192, 0.192),
    //     float4(0.180, 0.180, 0.180, 0.180),
    //     float4(0.135, 0.135, 0.135, 0.135)
    // };


    uint width, height;
    OutputTex.GetDimensions(width, height); 

    if (id.x >= width || id.y >= height)
        return;

    float4 sum = float4(0, 0, 0, 0);
    float totalWeight = 0.0;

    for (int i = 0; i < 5; ++i)
    {
        float2 offsetLeft = float2(-i * TexelSkip, 0);
        float2 offsetRight = float2(i * TexelSkip, 0);

        sum += InputTex[id.xy + offsetLeft] * weights[i];
        
        if (i != 0)
        {
            sum += InputTex[id.xy + offsetRight] * weights[i];
        }
        totalWeight += (i == 0) ? weights[i].r : 2 * weights[i].r;
    }

    OutputTex[id.xy] = sum / totalWeight;
} 

[numthreads(8, 8, 1)]
void VerticalBlur(uint3 id : SV_DispatchThreadID)
{
    const float4 weights[5] = {
        float4(0.227027, 0.227027, 0.227027, 0.227027),
        float4(0.1945946, 0.1945946, 0.1945946, 0.1945946),
        float4(0.1216216, 0.1216216, 0.1216216, 0.1216216),
        float4(0.054054, 0.054054, 0.054054, 0.054054),
        float4(0.016216, 0.016216, 0.016216, 0.016216)
    };
    // static const float4 weights[5] = {
    //     float4(0.104, 0.104, 0.104, 0.104),
    //     float4(0.169, 0.169, 0.169, 0.169),
    //     float4(0.192, 0.192, 0.192, 0.192),
    //     float4(0.180, 0.180, 0.180, 0.180),
    //     float4(0.135, 0.135, 0.135, 0.135)
    // };
    // static const float4 weights[5] = {
    //     float4(0.179, 0.179, 0.179, 0.179),  // 中心
    //     float4(0.168, 0.168, 0.168, 0.168),  // ±1
    //     float4(0.148, 0.148, 0.148, 0.148),  // ±2
    //     float4(0.121, 0.121, 0.121, 0.121),  // ±3
    //     float4(0.092, 0.092, 0.092, 0.092)   // ±4
    // };

    uint width, height;
    OutputTex.GetDimensions(width, height);

    if (id.x >= width || id.y >= height)
        return;

    float4 sum = float4(0, 0, 0, 0);
    float totalWeight = 0.0;

    for (int i = 0; i < 5; ++i)
    {
        float2 offsetUp = float2(0, -i * TexelSkip);
        float2 offsetDown = float2(0, i * TexelSkip);

        sum += InputTex[id.xy + offsetUp] * weights[i];
        if (i != 0)
        {
            sum += InputTex[id.xy + offsetDown] * weights[i];
        }
        totalWeight += (i == 0) ? weights[i].r : 2 * weights[i].r;
    }

    OutputTex[id.xy] = sum / totalWeight;
}